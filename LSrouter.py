import sys
from collections import defaultdict
from router import Router
from packet import Packet
from json import dumps, loads
from dijkstar import Graph,find_path



class LSrouter(Router):
    """Link state routing protocol implementation."""

    def __init__(self, addr, heartbeatTime):
        """TODO: add your own class fields and initialization code here"""
        Router.__init__(self, addr)  # initialize superclass - don't remove
        self.heartbeatTime = heartbeatTime
        self.last_time=0
        self.addr=addr
        self.sequence=0
        self.state=[]
        self.forward_table={}
        self.graph=Graph(undirected=True)
        self.add_status=True
        self.last_seq={}
        # Hints: initialize local state

    def handlePacket(self, port, packet):
        """TODO: process incoming packet"""
        if packet.srcAddr != self.addr:
            if packet.isTraceroute():
                # Hints: this is a normal data packet
                # if the forwarding table contains packet.dstAddr
                #   send packet based on forwarding table, e.g., self.send(port, packet)
                try:
                    path=find_path(self.graph,self.addr,packet.dstAddr)
                    node=path.nodes[1]
                    if node in self.forward_table.keys():
                        self.send(self.forward_table[node],packet)
                except Exception as e:
                    pass

            else:
                # Hints: this is a routing packet generated by your routing protocol
                # check the sequence number
                #   if the sequence number is higher and the received link state is different
                #   update the local copy of the link state
                #   update the forwarding table
                #   broadcast the packet to other neighbors
                msg=loads(packet.getContent())
                for i in self.forward_table.keys():
                    if self.forward_table[i] == port:
                        src=i
                        break

                if msg['removal']==True and self.last_seq[packet.srcAddr] < msg['seq']:
                    
                    #update seq
                    self.last_seq[packet.srcAddr]=msg['seq']

                    #update graph
                    try:
                        self.graph.remove_edge(msg['state'][0],msg['state'][1])
                    except Exception as E:
                        print(E)

                    #broadcast
                    self.sequence+=1
                    for i in self.forward_table.keys():
                        if self.forward_table[i] == port:
                            continue
                        else:
                            self.send(self.forward_table[i],packet) 



                elif packet.srcAddr not in self.last_seq.keys() or self.last_seq[packet.srcAddr] < msg['seq']:
                   
                    #update seq
                    self.last_seq[packet.srcAddr]=msg['seq'] 
                    
                    #update graph
                    for i in msg['state']:
                        a=i[0]
                        b=i[1]
                        c=i[2]
                        self.graph.add_edge(a,b,c)
                    
                    #update forwarding table
                    if src not in self.forward_table:
                        self.forward_table[src]=port

                    #broadcasting
                    self.sequence+=1
                    for i in self.forward_table.keys():
                        if self.forward_table[i]==port:
                            continue
                        else:
                            self.send(self.forward_table[i],packet)

                #print('here {} {}'.format(self.sequence,msg['seq']))
        

    def handleNewLink(self, port, endpoint, cost):
        """TODO: handle new link"""
        # Hints:
        # update the forwarding table
        # broadcast the new link state of this router to all neighbors

        #updataing forward table
        self.forward_table[endpoint]=port

        #make state
        state=[self.addr,endpoint,cost]
        
        #update state
        if state not in self.state:
            self.state.append(state)

        #update graph
        self.graph.add_edge(self.addr,endpoint,cost)

        #broadcast
        self.sequence+=1
        for i in self.forward_table.keys():
            a=Packet(2,self.addr,i,content=dumps({'state':self.state,'seq':self.sequence,'removal':False}))
            self.send(self.forward_table[i],a)


        


    def handleRemoveLink(self, port):
        """TODO: handle removed link"""
        # Hints:
        # update the forwarding table
        # broadcast the new link state of this router to all neighbors 

        #get addr
        for i in self.forward_table.keys():
            if self.forward_table[i]==port:
                a=i
                break

        #update forward table
        del self.forward_table[a]
        
        #remove edge
        self.graph.remove_edge(self.addr,a)

        #update state
        for i in self.state:
            if i[1] == a:
                self.state.remove(i)

        #just to be consistent
        state=[self.addr,a,69]

        #broadcasting
        self.sequence+=1
        for i in self.forward_table.keys():
            if i == a:
                continue
            else:
                b=Packet(2,self.addr,i,content=dumps({'state':state,'seq':self.sequence,'removal':True}))
                self.send(self.forward_table[i],b)
        


    def handleTime(self, timeMillisecs):
        """TODO: handle current time"""
        if timeMillisecs - self.last_time >= self.heartbeatTime:
            self.last_time = timeMillisecs
            # Hints:
            # broadcast the link state of this router to all neighbors
            self.sequence+=1
            for i in self.forward_table.keys():
                a=Packet(2,self.addr,i,content=dumps({'state':self.state,'seq':self.sequence,'removal':False}))
                self.send(self.forward_table[i],a)

    def debugString(self):
        """TODO: generate a string for debugging in network visualizer"""
        return dumps(str(self.graph))
